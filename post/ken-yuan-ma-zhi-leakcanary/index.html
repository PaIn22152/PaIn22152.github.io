<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>å•ƒæºç ä¹‹--LeakCanary | Payneçš„å°ç«™</title>
<meta name="description" content="å…‹å·±ã€ç§¯ç´¯ã€åšæŒã€æ ¼å±€ã€å…¨åŠ›ä»¥èµ´
å¯¹è¿‡ç¨‹çš„å…³æ³¨è¦å¤šäºå¯¹ç»“æœçš„å…³æ³¨">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="shortcut icon" href="https://PaIn22152.github.io/favicon.ico">
<link rel="stylesheet" href="https://PaIn22152.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://PaIn22152.github.io">
        <img src="https://PaIn22152.github.io/images/avatar.png" class="site-logo">
        <h1 class="site-title">Payneçš„å°ç«™</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            é¦–é¡µ
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            å½’æ¡£
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            æ ‡ç­¾
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            å…³äº
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="site-description">
      å…‹å·±ã€ç§¯ç´¯ã€åšæŒã€æ ¼å±€ã€å…¨åŠ›ä»¥èµ´
å¯¹è¿‡ç¨‹çš„å…³æ³¨è¦å¤šäºå¯¹ç»“æœçš„å…³æ³¨
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">å•ƒæºç ä¹‹--LeakCanary</h2>
            <div class="post-date">2022-01-18</div>
            
            <div class="post-content">
              <h1 id="0å‰è¨€">0.å‰è¨€</h1>
<p>Androidå¼€å‘ä¸­ï¼Œå†…å­˜æ³„éœ²æ˜¯å¼•å‘OOMçš„ä¸€å¤§åŸå› ï¼Œä¸ºäº†é¿å…å†…å­˜æ³„éœ²çš„å‘ç”Ÿï¼Œé€šå¸¸ä½¿ç”¨<a href="https://github.com/square/leakcanary">LeakCanary</a>æ¥æ£€æµ‹æ˜¯å¦å‘ç”Ÿäº†å†…å­˜æ³„éœ²ï¼Œæ¥ä¸‹æ¥å°±æ ¹æ®LeakCanaryæºç ï¼ˆç‰ˆæœ¬ 2.8.1 ï¼‰ï¼Œæ¥çœ‹çœ‹æ˜¯æ€ä¹ˆå®ç°å†…å­˜æ³„éœ²çš„æ£€æµ‹çš„ã€‚</p>
<h1 id="1åˆå§‹åŒ–">1.åˆå§‹åŒ–</h1>
<p>è‡ª2.0ç‰ˆæœ¬ä¹‹åï¼ŒLeakCanaryéƒ½ä¸éœ€è¦åœ¨ä»£ç ä¸­ä¸»åŠ¨åˆå§‹åŒ–ï¼Œåªéœ€è¦åœ¨build.gradleä¸­å¼•å…¥é¡¹ç›®å³å¯ï¼š</p>
<pre><code class="language-groovy">dependencies {
  // debugImplementation because LeakCanary should only run in debug builds.
  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.8.1'
}
</code></pre>
<p>è¿™æ˜¯å› ä¸ºé¡¹ç›®åœ¨è‡ªå·±çš„ContentProviderä¸­è‡ªåŠ¨åˆå§‹åŒ–äº†<br>
è¿™é‡Œæœ‰ä¸€ä¸ªçŸ¥è¯†ç‚¹ï¼Œé‚£å°±æ˜¯ContentProviderçš„onCreate()æ–¹æ³•ï¼Œä¼šåœ¨Applicationçš„onCreate()æ–¹æ³•ä¹‹å‰æ‰§è¡Œã€‚<br>
é¡¹ç›®ä¸­çš„ç›¸å…³æºç å¦‚ä¸‹ï¼š<br>
<a href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/AndroidManifest.xml">leakcanary/leakcanary-object-watcher-android/src/main/AndroidManifest.xml</a></p>
<pre><code class="language-xml">  &lt;application&gt;
    &lt;provider
        android:name=&quot;leakcanary.internal.MainProcessAppWatcherInstaller&quot;
        android:authorities=&quot;${applicationId}.leakcanary-installer&quot;
        android:enabled=&quot;@bool/leak_canary_watcher_auto_install&quot;
        android:exported=&quot;false&quot;/&gt;
  &lt;/application&gt;
</code></pre>
<pre><code class="language-kotlin">/**
 * Content providers are loaded before the application class is created. [MainProcessAppWatcherInstaller] is
 * used to install [leakcanary.AppWatcher] on application start.
 *
 * [MainProcessAppWatcherInstaller] automatically sets up the LeakCanary code that runs in the main
 * app process.
 */
internal class MainProcessAppWatcherInstaller : ContentProvider() {

  override fun onCreate(): Boolean {
    val application = context!!.applicationContext as Application
    AppWatcher.manualInstall(application)
    return true
  }

  override fun query(
    uri: Uri,
    projectionArg: Array&lt;String&gt;?,
    selection: String?,
    selectionArgs: Array&lt;String&gt;?,
    sortOrder: String?
  ): Cursor? = null

  override fun getType(uri: Uri): String? = null

  override fun insert(uri: Uri, contentValues: ContentValues?): Uri? = null

  override fun delete(uri: Uri, selection: String?, selectionArgs: Array&lt;out String&gt;?): Int = 0

  override fun update(
    uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array&lt;out String&gt;?
  ): Int = 0
}
</code></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œåœ¨MainProcessAppWatcherInstallerè¿™ä¸ªContentProviderçš„å­ç±»ä¸­ï¼Œåªåœ¨onCreate()æ–¹æ³•ä¸‹åˆå§‹åŒ–äº†LeakCanaryåº“ï¼Œå…¶ä»–çš„æ–¹æ³•å…¨æ˜¯ç©ºå®ç°ã€‚</p>
<h1 id="2å›æ”¶ç›‘å¬">2.å›æ”¶ç›‘å¬</h1>
<p>é¦–å…ˆè¦çŸ¥é“ï¼ŒLeakCanaryæ£€æµ‹ä»€ä¹ˆå¯¹è±¡çš„æ³„éœ²ï¼Ÿ<br>
åœ¨<a href="https://square.github.io/leakcanary/getting_started/">å®˜ç½‘</a>æœ‰å¦‚ä¸‹çš„æè¿°ï¼š</p>
<blockquote>
<p>LeakCanary automatically detects leaks of the following objects:<br>
destroyed Activity instances<br>
destroyed Fragment instances<br>
destroyed fragment View instances<br>
cleared ViewModel instances</p>
</blockquote>
<p>æ‰€ä»¥ï¼ŒLeakCanaryæ˜¯åœ¨æ£€æµ‹Activityï¼ŒFragmentï¼ŒFragmentä¸­çš„Viewï¼ŒViewModelè¿™å‡ ç§å¯¹è±¡æ˜¯å¦æ³„éœ²ï¼Œæ¥ä¸‹æ¥çœ‹çœ‹æ˜¯æ€ä¹ˆç›‘å¬å¯¹è±¡çš„ã€‚</p>
<p>åˆå§‹åŒ–æ–¹æ³•ä¸º AppWatcher.manualInstall(application)ï¼Œæºç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-kotlin">@JvmOverloads
  fun manualInstall(
    application: Application,
    retainedDelayMillis: Long = TimeUnit.SECONDS.toMillis(5),
    watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)
  ) {
    checkMainThread()
    if (isInstalled) {
      throw IllegalStateException(
        &quot;AppWatcher already installed, see exception cause for prior install call&quot;, installCause
      )
    }
    check(retainedDelayMillis &gt;= 0) {
      &quot;retainedDelayMillis $retainedDelayMillis must be at least 0 ms&quot;
    }
    installCause = RuntimeException(&quot;manualInstall() first called here&quot;)
    this.retainedDelayMillis = retainedDelayMillis
    if (application.isDebuggableBuild) {
      LogcatSharkLog.install()
    }
    // Requires AppWatcher.objectWatcher to be set
    LeakCanaryDelegate.loadLeakCanary(application)

    watchersToInstall.forEach {
      it.install()
    }
  }
</code></pre>
<p>è¿™é‡Œæœ‰ä¸¤ä¸ªå…³é”®ä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯retainedæ—¶é—´é»˜è®¤5ç§’ï¼ˆåæ–‡ä¼šè¯¦ç»†è¯´retainedæ˜¯ä»€ä¹ˆï¼‰ï¼Œå¦ä¸€ä¸ªæ˜¯é»˜è®¤è§‚å¯Ÿè€…æ˜¯appDefaultWatchersï¼ŒappDefaultWatchersçš„æºç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-kotlin">  /**
   * Creates a new list of default app [InstallableWatcher], created with the passed in
   * [reachabilityWatcher] (which defaults to [objectWatcher]). Once installed,
   * these watchers will pass in to [reachabilityWatcher] objects that they expect to become
   * weakly reachable.
   *
   * The passed in [reachabilityWatcher] should probably delegate to [objectWatcher] but can
   * be used to filter out specific instances.
   */
  fun appDefaultWatchers(
    application: Application,
    reachabilityWatcher: ReachabilityWatcher = objectWatcher
  ): List&lt;InstallableWatcher&gt; {
    return listOf(
      ActivityWatcher(application, reachabilityWatcher),
      FragmentAndViewModelWatcher(application, reachabilityWatcher),
      RootViewWatcher(reachabilityWatcher),
      ServiceWatcher(reachabilityWatcher)
    )
  }
</code></pre>
<p>çœ‹åˆ°è¿™é‡Œï¼Œå·²ç»è±ç„¶å¼€æœ—ï¼Œè¿™äº›è§‚å¯Ÿè€…å°±æ˜¯åœ¨å¯¹ä¸åŒçš„å¯¹è±¡è¿›è¡Œç›‘å¬ï¼Œé™¤äº†ä¸Šæ–‡è¯´åˆ°çš„4ä¸ªå¤–ï¼Œè¿˜å¯ä»¥ç›‘å¬Serviceï¼ŒæŸ¥äº†ä¸€ä¸‹<a href="https://square.github.io/leakcanary/changelog/">æ›´æ–°æ—¥å¿—</a>ï¼Œè¿™æ˜¯åœ¨Version 2.6 - Christmas Release ğŸ„ (2020-12-24)ç‰ˆæœ¬æ–°å¢çš„åŠŸèƒ½ï¼Œåº”è¯¥æ˜¯å®˜ç½‘é¦–é¡µæ²¡æœ‰åŠæ—¶æ›´æ–°æ˜¾ç¤ºå†…å®¹ã€‚</p>
<p>å†è·Ÿè¸ªActivityWatcheræ–¹æ³•ï¼Œæºç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-kotlin">/**
 * Expects activities to become weakly reachable soon after they receive the [Activity.onDestroy]
 * callback.
 */
class ActivityWatcher(
  private val application: Application,
  private val reachabilityWatcher: ReachabilityWatcher
) : InstallableWatcher {

  private val lifecycleCallbacks =
    object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
      override fun onActivityDestroyed(activity: Activity) {
          //æ³¨é‡Š1
        reachabilityWatcher.expectWeaklyReachable(
          activity, &quot;${activity::class.java.name} received Activity#onDestroy() callback&quot;
        )
      }
    }

  override fun install() {
    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)
  }

  override fun uninstall() {
    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)
  }
}
</code></pre>
<p>ç›‘å¬activityçš„ç”Ÿå‘½å‘¨æœŸï¼Œå½“å‘ç”Ÿdestoryåï¼Œè§¦å‘æ³¨é‡Š1å¤„çš„æ£€æµ‹ï¼Œæœ€åæ˜¯ç”±ObjectWatcher.expectWeaklyReachable()æ–¹æ³•å¤„ç†ï¼Œå…¶ä»–å‡ ä¸ªçš„ç›‘å¬å’Œactivityç±»ä¼¼ï¼Œæœ€ç»ˆéƒ½äº¤ç»™ObjectWatcher.expectWeaklyReachable()æ–¹æ³•å¤„ç†ã€‚</p>
<h1 id="3å›æ”¶æ£€æµ‹">3.å›æ”¶æ£€æµ‹</h1>
<p>ä¸Šæ–‡è¯´åˆ°ï¼Œå½“ç›‘å¬åˆ°å¯¹è±¡çš„destoryåï¼Œè§¦å‘ObjectWatcher.expectWeaklyReachable()æ–¹æ³•æ‰§è¡Œå›æ”¶æ£€æµ‹ï¼Œæºç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-kotlin">  @Synchronized override fun expectWeaklyReachable(
    watchedObject: Any,
    description: String
  ) {
    if (!isEnabled()) {
      return
    }
    removeWeaklyReachableObjects()
    val key = UUID.randomUUID()
      .toString()
    val watchUptimeMillis = clock.uptimeMillis()
    val reference =
      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)
    SharkLog.d {
      &quot;Watching &quot; +
        (if (watchedObject is Class&lt;*&gt;) watchedObject.toString() else &quot;instance of ${watchedObject.javaClass.name}&quot;) +
        (if (description.isNotEmpty()) &quot; ($description)&quot; else &quot;&quot;) +
        &quot; with key $key&quot;
    }

    watchedObjects[key] = reference
    checkRetainedExecutor.execute {
      moveToRetained(key)
    }
  }
</code></pre>
<p>å…ˆæ ¹æ®å½“å‰å¯¹è±¡ï¼Œç”Ÿæˆä¸€ä¸ªå¼±åº”ç”¨å¯¹è±¡ï¼Œç„¶åæ”¾åˆ°é˜Ÿåˆ—ä¸­ï¼Œ5ç§’åæ£€æµ‹é˜Ÿåˆ—é‡Œé¢çš„å¼±å¼•ç”¨å¯¹è±¡æ˜¯å¦å·²ç»å›æ”¶ã€‚<br>
ä½¿ç”¨removeWeaklyReachableObjectså’ŒmoveToRetainedæ–¹æ³•å®ç°ï¼Œ<br>
removeWeaklyReachableObjectsæ˜¯ç§»é™¤æ‰€æœ‰å·²ç»å›æ”¶çš„å¼•ç”¨ï¼Œ<br>
moveToRetainedæ˜¯åœ¨æ­¤5ç§’åæ‰§è¡Œï¼ˆ5ç§’å°±æ˜¯ä¸Šæ–‡æåˆ°çš„retainedæ—¶é—´ï¼‰ï¼Œå†æ¬¡ç§»é™¤æ‰€æœ‰å›æ”¶çš„å¼•ç”¨ï¼Œå¦‚æœè¿™ä¸ªæ—¶å€™è¿˜æœ‰å¼•ç”¨å­˜åœ¨ï¼Œè¯´æ˜å¯¹è±¡æ²¡ç”¨è¢«å›æ”¶ï¼Œå­˜åœ¨æ³„éœ²çš„é£é™©ã€‚</p>
<h1 id="4å›è°ƒå¤„ç†">4.å›è°ƒå¤„ç†</h1>
<p>å½“æ£€æµ‹åˆ°æ³„éœ²çš„å¯¹è±¡ï¼Œé€šè¿‡OnObjectRetainedListener.onObjectRetained()å›è°ƒå¤„ç†ï¼Œå¤„ç†å†…å®¹åŒ…æ‹¬è·å–å†…å­˜å¿«ç…§ï¼Œç”Ÿæˆhprofæ–‡ä»¶ï¼Œè§£æhprofæ–‡ä»¶ï¼Œæ‰¾åˆ°å†…å­˜æ³„éœ²å¯¹è±¡ï¼Œè®¡ç®—åˆ°å¯¹è±¡åˆ°GC rootsçš„æœ€çŸ­è·¯å¾„å¹¶åˆå¹¶æˆä¸€æ£µæ ‘ï¼Œè¾“å‡ºåˆ†æç»“æœç­‰ã€‚<br>
å…³äºå›è°ƒå¤„ç†çš„è¿‡ç¨‹ï¼Œè¿‡äºå¤æ‚ä¸”ä¸æ˜¯æœ¬æ–‡çš„é‡ç‚¹ï¼Œä¸è¿‡å¤šä»‹ç»ã€‚</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">ä¸‹ä¸€ç¯‡</div>
                <a href="https://PaIn22152.github.io/post/liao-liao-websocket/">
                  <h3 class="post-title">
                    èŠèŠWebSocket
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
